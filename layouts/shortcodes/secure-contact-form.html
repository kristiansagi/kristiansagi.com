{{/* secure-contact-form.html — Hugo shortcode with Turnstile integration */}}

{{- $origin  := .Get "origin"  | default "https://kristiansagi.com" -}}
{{- $subject := .Get "subject" | default "Encrypted message via contact page" -}}
{{- $title   := .Get "title"   | default "Send a secure message" -}}
{{- $id      := printf "contact-secure-%d" now.UnixNano -}}

<link rel="stylesheet" href="/css/secure-form.css">

<section id="{{ $id }}" class="pm-card pm-secure"
         data-origin="{{ $origin }}"
         data-subject="{{ $subject }}">
  <header class="pm-card__header">
    <h3 class="pm-card__title">{{ $title }}</h3>
  </header>

  <div class="pm-card__body">
    <div class="pm-field">
      <label for="{{ $id }}-from" class="pm-label">Your Name &amp; Email</label>
      <input id="{{ $id }}-from" type="text" class="pm-input"
             placeholder="Jane Doe · jane@example.com" autocomplete="off" spellcheck="false" />
      <p class="pm-help">An email address is required.</p>
    </div>

    <div class="pm-field">
      <label for="{{ $id }}-msg" class="pm-label">Message</label>
      <textarea id="{{ $id }}-msg" class="pm-textarea" rows="7"
                placeholder="Write your message…"></textarea>
    </div>
  </div>

  <footer class="pm-card__footer">
    <button type="button" class="pm-btn pm-btn--primary">Send</button>
  </footer>

  <!-- Turnstile widget (key chosen at runtime) -->
  <div id="{{ $id }}-cf" class="cf-turnstile"
       data-size="invisible"
       data-refresh-expired="auto"
       data-callback="{{ $id }}_cf_ok"
       data-error-callback="{{ $id }}_cf_err"
       data-expired-callback="{{ $id }}_cf_expired"></div>
</section>

<!-- Turnstile runtime -->
<script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
<script src="/js/openpgp.min.js"></script>
<script>
(function init(id){
  const root = document.getElementById(id);
  if (!root || root.dataset.bound === '1') return;
  root.dataset.bound = '1';

  const SUBJECT = root.dataset.subject;

  // Resolve endpoints/keys per environment
  const isLocal = /^(localhost|127\.0\.0\.1)$/.test(location.hostname);
  const origin = location.origin; // use the current host (staging/prod)
  const PUBKEY_URL = origin + '/kristian-sagi-pub.asc';

  // Turnstile: choose sitekey by hostname
  const SITEKEYS = {
    "kristiansagi.com": "{{ site.Params.turnstile.site_key }}",
    "www.kristiansagi.com": "{{ site.Params.turnstile.site_key }}",
    "staging.kristiansagi.com": "{{ site.Params.turnstile.site_key_staging }}"
  };
  const SITEKEY = SITEKEYS[location.hostname] || "{{ site.Params.turnstile.site_key }}";

  // Worker endpoint: workers.dev for local, route for deployed
  const WORKER_SEND_URL = 'https://send-encrypted.kristian-b24.workers.dev/api/send-encrypted';
  const SEND_ENDPOINT = isLocal ? WORKER_SEND_URL : '/api/send-encrypted';

  const fromEl = root.querySelector('#' + id + '-from');
  const msgEl  = root.querySelector('#' + id + '-msg');
  const btn    = root.querySelector('.pm-btn');
  const cfDiv  = document.getElementById(id + '-cf');

  // Render Turnstile with the chosen key
  const renderTurnstile = () => {
    if (!window.turnstile || !cfDiv) return;
    // attach sitekey dynamically
    cfDiv.setAttribute('data-sitekey', SITEKEY);
    try { turnstile.render(cfDiv); } catch(_) {}
  };

  // Token state
  let cfToken = "";
  let pendingCipher = null;
  let attemptId = 0;

  // Utilities
  async function fetchTxt(u){ const r = await fetch(u,{cache:'no-store'}); if(!r.ok) throw new Error('HTTP '+r.status+' '+u); return r.text(); }
  let pubKey; async function loadKey(){ if(pubKey) return pubKey; pubKey = await fetchTxt(PUBKEY_URL); return pubKey; }
  async function encryptPlain(text){
    const k = await loadKey();
    const key = await openpgp.readKey({armoredKey:k});
    const m = await openpgp.createMessage({text});
    return openpgp.encrypt({message:m, encryptionKeys:key});
  }
  function clearForm(){ fromEl.value=''; msgEl.value=''; }

  // Turnstile callbacks must be global
  window[id + '_cf_ok'] = async (token) => {
    const myId = Number(cfDiv?.dataset.attempt || 0);
    if (myId !== attemptId) return; // stale callback

    try{
      if (!token || !pendingCipher) throw new Error('Verification error. Please try again.');
      cfToken = token;

      btn.textContent = 'Sending…';
      const res = await fetch(SEND_ENDPOINT,{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ subject: SUBJECT, ciphertext: pendingCipher.trim(), cfToken })
      });
      const data = await res.json().catch(()=>({}));

      if(!res.ok || !data.ok) {
        // Bubble Turnstile details if present
        const reason = (data && data.details && (data.details['error-codes']||data.details.error || data.error)) || res.status;
        throw new Error('Send failed: ' + reason);
      }

      clearForm();
      btn.classList.add('pm-btn--sent'); btn.textContent = 'Sent ✓';
    }catch(err){
      btn.textContent = 'Send'; btn.disabled = false;
      alert(err.message || String(err));
    }finally{
      pendingCipher = null; cfToken = "";
      if (window.turnstile && cfDiv) turnstile.reset(cfDiv);
    }
  };
  window[id + '_cf_err'] = () => {
    pendingCipher = null; cfToken = "";
    btn.disabled = false; btn.textContent = 'Send';
    if (window.turnstile && cfDiv) turnstile.reset(cfDiv);
    alert('Verification error. Please try again.');
  };
  window[id + '_cf_expired'] = () => {
    cfToken = "";
    if (window.turnstile && cfDiv) turnstile.reset(cfDiv);
  };

  // Refresh token when the tab becomes visible
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && window.turnstile && cfDiv) {
      try { turnstile.reset(cfDiv); } catch(_) {}
    }
  });

  // Bind send
  btn.addEventListener('click', async (e)=>{
    e.preventDefault();
    const from = (fromEl.value||'').trim();
    const body = (msgEl.value||'').trim();
    if(!from || !body){ alert('Please fill both fields.'); return; }

    try{
      btn.disabled = true; btn.textContent = 'Encrypting…';
      const composed = [
        `From: ${from}`,
        `Origin: ${location.origin}`,
        `Time: ${new Date().toISOString()}`,
        '---',
        body
      ].join('\n');
      pendingCipher = await encryptPlain(composed);

      // get a fresh token just-in-time
      btn.textContent = 'Verifying…';
      attemptId += 1;
      if (cfDiv) cfDiv.dataset.attempt = String(attemptId);
      if (!window.turnstile || !cfDiv) throw new Error('Captcha unavailable.');
      try { turnstile.reset(cfDiv); } catch(_) {}
      turnstile.execute(cfDiv);
    }catch(err){
      pendingCipher = null; btn.disabled = false; btn.textContent = 'Send';
      alert(err.message || String(err));
    }
  });

  // Initial render of Turnstile
  const ready = () => { if (window.turnstile) renderTurnstile(); else setTimeout(ready, 50); };
  ready();
})('{{ $id }}');
</script>
